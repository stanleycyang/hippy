#! /usr/bin/env babel-node

'use strict';

var program = require('commander');
var mkdirp = require('mkdirp');
var fs = require('fs');
var path = require('path');
var readline = require('readline');

var exit = process.exit;

// Grab the version from package.json
var version = require('../package.json').version;

process.exit = exit;

// Files
var files = undefined;

program.version(version).option('-f, --force', 'force on a pre-existing file').command('g <file> [otherFiles...]').action(function (file, otherFiles) {
  otherFiles.unshift(file);
  files = otherFiles;
});

program.parse(process.argv);

if (!exit.exited) {
  // Execute the main program
  main();
}

/*
 * Main program
 */

function main() {
  if (typeof files === 'undefined') {
    console.error('no command given!');
    process.exit(1);
  }

  console.log('Starting Hippy...');

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = files[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var file = _step.value;

      checkFilePath(file, createFile);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

/*
 * @param {String} path
 * @param {Function} fn
 */

function checkFilePath(path, fn) {
  try {
    stats = fs.lstatSync(path);
    if (stats === null) {
      if (program.force) {
        fn(path);
      } else {
        // Ask for permission
        confirm('The file ' + path + ' already exists. Overwrite? [y/N]', function (ok) {
          if (ok) {
            process.stdin.destroy();
            fn(path);
          } else {
            console.error('abort');
            exit(1);
          }
        });
      }
    }
  } catch (e) {
    switch (e.code) {
      case 'ENOENT':
        // Safe to write
        fn(path);
        break;
      default:
        throw e;
    }
  }
}

/*
 * @param {String} name
 */

function createFile(name) {
  var component = loadTemplate('Component.js');
  component = component.replace('{name}', name);

  // Write the component
  write(name, component);
}

/*
 * Prompt for confirmation to force
 * @param {String} msg
 * @param {Function} callback
 */

function confirm(msg, callback) {
  var rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  rl.question(msg, function (input) {
    rl.close();
    callback(/^y|yes|ok|true$/i.test(input));
  });
}

/*
 * @param {String} name
 */

function loadTemplate(name) {
  return fs.readFileSync(path.join(__dirname, '..', 'templates', name), 'utf-8');
}

/*
 * @param {String} path
 * @param {String} str
 */

function write(path, str, mode) {
  fs.writeFileSync(path, str, { mode: mode || '0666' });
  console.log('\x1b[36mcreated\x1b[0m: ' + path);
}

/**
 * Graceful exit
 */

function exit(code) {
  function done() {
    if (! draining--) _exit(code);
  }

  var draining = 0;
  var streams = [process.stdout, process.stderr];

  exit.exited = true;

  streams.forEach(function (stream) {
    // submit empty write request and wait for completion
    draining += 1;
    stream.write('', done);
  });

  done();
}